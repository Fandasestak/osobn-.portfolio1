<!doctype html>
  <html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>만sty</title>
    <link rel="shortcut icon" href="fsLogo4.svg" type="image/x-icon">
    <link href='https://cdn.boxicons.com/fonts/brands/boxicons-brands.min.css' rel='stylesheet'>
    <link rel="stylesheet" href="style.css">
    <script src="https://unpkg.com/boxicons@2.1.4/dist/boxicons.js"></script>
  </head>
  <body>
    <div class="app">
      <!-- three-bg je te캞 v pop콏ed칤 s vy코코칤m z-indexem -->
      <div id="three-bg" class="three-wrap" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:10;pointer-events:none;overflow:hidden;"></div>
      <header>
        <div class="brand">
          <div class="logo-wrap">

            
            <div id="logoHolder" class="logo-scratch" title="Scorpio Holding owner">
              <div id="logoSVGWrap" class="logo-rotate" style="width:72px;height:72px;display:grid;place-items:center">
                <a href="https://sesty.dev"><img src="fsLogo5.svg" alt="Logo" id="sestySVG" style="width:48px;height:48px;user-select:none;pointer-events:none"></a>
              </div>
            </div>
          </div>

          <div class="brand-text">
            <div class="sesty_nadpis">만sty</div>
            <div style="font-size:12px;color:rgba(255,255,255,0.6)">Franti코ek 만st치k</div>
          </div>
        </div>


        <div style="display:flex;gap:10px;align-items:center" class="desktop-nav">
          <nav class="nav">
            
            <a href="#home">Dom콢</a>
            <a href="#aboutme">O mn캩</a>
            <a href="#projects">Projekty</a>
            <a href="#contact">Kontakt</a>
          </nav>
          
        </div>

        <div class="hamburger-button" id="hamburgerButton">
                <span class="hamburger-icon"></span>
            </div>

      </header>

      <nav class="mobile-menu" id="mobileMenu">
        <a href="https://sesty.dev">Dom콢</a>
        <a href="#aboutme">O mn캩</a>
        <a href="#projects">Projekty</a>
        <a href="#contact">Kontakt</a>
      </nav>


      <div class="hscroller" id="scroller" tabindex="0">
        <section class="panel" id="home">
          <div class="card">
            <h1 class="modern">Dom콢</h1>
            <div class="modern_text bar" style="display: flex; justify-content: center; align-items: center; flex-direction: column;">
               <p class="modern_text">V칤tejte v m칠m portfoliu, v rychlosti se v치m p콏edstav칤m:</p>
            </div>
           
            <div style="margin-top:18px;display:flex;gap:12px;justify-content:center">
              <a class="cta" href="#projects" style="text-decoration:none">Projekty</a>
              <a class="cta" href="#aboutme" style="text-decoration:none"><box-icon name='right-arrow-alt' animation='tada' color='#aa8541' width="100px"></box-icon></a>
            </div>
          </div>
        </section>
</header>
       
        <section class="panel" id="aboutme">
          
          <div class="card">
            <h1 class="modern">O mn캩</h1>
            <div class="modern_text" style="display: flex; justify-content: center; align-items: center;">
               <p class="modern_text">Tak쬰... U캜칤m se programovat a designovat webov칠 str치nky (HTML, CSS, JS), i programovat v 驕됊잹 webov칠 aplikace. Zde je i reference na m칠ho kamar치da <a href="https://skymmel.eu/" style="color: #aa8541">Vojtu Wilhelma Skybu</a>, kter칳 mi s webem pom치hal.</p>
            </div>
            <div class="ref" style="margin-top:18px;display:flex;gap:12px;justify-content:center">
              <button class="cta" onclick="downloadCV()">콯ivotopis (洧릟洧릝洧릟洧릡)</button>
            </div>
          </div>
        </section>

        <section class="panel" id="projects">
          <div class="card">
            <h1 class="modern">Projekty</h1>
            <div style="display: flex; justify-content: center; align-items: center; flex-direction: column;">
              <h2 style="align-items: left; justify-content: left;" class="modern_text">Moje firma</h2>
              <img src="projekt1.png" width="80%" class="obrazek" style="border:5px solid #2362de; border-radius: 10px;">
              <a href="" style="color:#aa8541" >Scorpio.company</a>
            </div>
          </div>
        </section>

        <section class="panel" id="contact">
          <div class="card obrazek">
            <h1 class="modern">Kontaktuj m캩...</h1>
              <div class="social-media" style="display: flex; justify-content: center; align-items: center; gap: 30px; margin-top: 20px; width: 100%;">
                <a href="mailto:frantisek.sestak@tutamail.com" class="la" title="frantisek.sestak@tutamail.com"><box-icon name='gmail' type='logo' animation='tada' color='#aa8541' ></box-icon></a>
                <a href="tel:+420602813911" class="la" title="+420 602 813 911"><box-icon name='phone-call' type='solid' animation='tada' color='#ffffff' ></box-icon></a>
                <a href="https://www.instagram.com/fsestak9" class="la" title="@fsestak9"><box-icon name='instagram' type='logo' color='#aa8541'animation="tada"></box-icon></a>
                <a href="https://github.com/Fandasestak" class="la" title="Github link:"><box-icon name='github' type='logo' color='#ffffff'animation="tada"></box-icon></a>
              </div> 
          </div>
        </section>
      </div>

      
      <div class="blob a"></div>
      <div class="blob b"></div>
    </div>
  <!-- THREE.js pro 3D pozad칤 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
      document.addEventListener('DOMContentLoaded', () => {
            const hamburgerButton = document.getElementById('hamburgerButton');
            const mobileMenu = document.getElementById('mobileMenu');
            
            // Z칤sk치me odkazy uvnit콏 mobiln칤ho menu pro automatick칠 zav콏en칤
            const mobileMenuLinks = mobileMenu ? mobileMenu.querySelectorAll('a') : [];

            function toggleMenu() {
                if (!hamburgerButton || !mobileMenu) return;

                // P콏ep칤n치 t콏칤du 'open' (pro animaci X)
                hamburgerButton.classList.toggle('open');
                // P콏ep칤n치 t콏칤du 'open' (pro vysunut칤/zasunut칤 menu)
                mobileMenu.classList.toggle('open');
                
                // Zabr치n칤 scrollov치n칤 str치nky pod menu
                document.body.style.overflow = mobileMenu.classList.contains('open') ? 'hidden' : '';
            }

            // 1. P콏id치n칤 poslucha캜e na kliknut칤 pro hamburger tla캜칤tko
            if (hamburgerButton) {
                hamburgerButton.addEventListener('click', toggleMenu);
            }

            // 2. Zav콏en칤 menu po kliknut칤 na odkaz
            mobileMenuLinks.forEach(link => {
                link.addEventListener('click', () => {
                    setTimeout(() => {
                        if (mobileMenu.classList.contains('open')) {
                            toggleMenu(); 
                        }
                    }, 200); 
                });
            });
        });





      // 1) Vertical wheel -> horizontal scroll mapping (desktop)
      const scroller = document.getElementById('scroller');


      let wheelLock = false;
      let wheelAccum = 0;
      let wheelTimer = null;
      let lastScrollLeft = scroller.scrollLeft;
      const WHEEL_THRESHOLD = 80;
      const panelCount = document.querySelectorAll('.panel').length;

      scroller.addEventListener('wheel', (e) => {
        if (Math.abs(e.deltaY) < Math.abs(e.deltaX)) return;
        e.preventDefault();
        if (wheelLock) return;

        wheelAccum += e.deltaY;
        clearTimeout(wheelTimer);
        wheelTimer = setTimeout(() => {
          if (Math.abs(wheelAccum) >= WHEEL_THRESHOLD) {
            wheelLock = true;
            
            const currentPanel = Math.round(scroller.scrollLeft / scroller.clientWidth);
            const isFirstPanel = currentPanel <= 0;
            const isLastPanel = currentPanel >= panelCount - 1;
            
            // Povolen칤 scrollov치n칤 v obou sm캩rech
            if (wheelAccum < 0) { // scroll nahoru/zp캩t
              if (!isFirstPanel) { // nen칤 prvn칤 panel, m콢쬰me j칤t zp캩t
                scroller.scrollBy({left: -scroller.clientWidth, behavior: 'smooth'});
              }
            } else { // scroll dol콢/vp콏ed
              if (!isLastPanel) { // nen칤 posledn칤 panel, m콢쬰me j칤t vp콏ed
                scroller.scrollBy({left: scroller.clientWidth, behavior: 'smooth'});
              }
            }
            
            setTimeout(() => { wheelLock = false; }, 100); // del코칤 pauza pro plynulej코칤 scrollov치n칤
          }
          wheelAccum = 0;
        }, 10);
      }, {passive:false});

      // 2) Mobile: swipe/scroll in both directions based on touch movement
      let touchStartX = 0;
      let touchStartY = 0;
      let touchMoved = false;
      scroller.addEventListener('touchstart', function(e) {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchMoved = false;
        }
      });
      scroller.addEventListener('touchmove', function(e) {
        if (e.touches.length === 1) {
          const touchEndX = e.touches[0].clientX;
          const diffX = touchStartX - touchEndX;
          
          // Ur캜칤 sm캩r scrollu podle rozd칤lu v X sou콏adnici
          if (Math.abs(diffX) > 50) { // minim치ln칤 pr치h pro scroll
            touchMoved = true;
          }
        }
      });
      scroller.addEventListener('touchend', function(e) {
        if (!touechMovd) return;
        const touchEndX = e.changedTouches[0].clientX;
        const diffX = touchStartX - touchEndX;
        
        // Scroll podle sm캩ru swipe
        if (diffX > 50) { // swipe doleva
          scroller.scrollBy({left: scroller.clientWidth, behavior: 'smooth'});
        } else if (diffX < -50) { // swipe doprava
          scroller.scrollBy({right: -scroller.clientWidth, behavior: 'smooth'});
        }
      });

      // keyboard navigation
      window.addEventListener('keydown', (e)=>{ if(e.key==='ArrowRight') scroller.scrollBy({left: scroller.clientWidth, behavior:'smooth'}); if(e.key==='ArrowLeft') scroller.scrollBy({left:-scroller.clientWidth, behavior:'smooth'}) });
      function scrollNext(){ scroller.scrollBy({left: scroller.clientWidth, behavior: 'smooth'}) }
      window.scrollNext = scrollNext;

      function downloadCV() {
    const link = document.createElement('a');
    link.href = 'zivotopis.pdf'; // n치zev a cesta k tv칠mu PDF
    link.download = '콯ivotopis';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
  window.downloadCV = downloadCV;
      
      // 3D background only for desktop (width >= 1025px)
      (function createBackground() {
        // Check screen width before initializing 3D effect
        if (window.innerWidth < 1025) {
          const container = document.getElementById('three-bg');
          if (container) container.style.display = 'none';
          return;
        }

        const container = document.getElementById('three-bg');
        if (container) container.style.display = 'block';
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ 
          alpha: true,
          antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Sv캩tla
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.0);
        pointLight.position.set(0, 0, 5);
        scene.add(pointLight);

        // Vytvo콏en칤 캜치stic
        const particles = [];
        const particleCount = 1500; // Zv칳코en칳 po캜et 캜치stic pro lep코칤 detail p칤smena F
        const colors = [0xffffff, 0x3b82f6, 0xaa8541]; // B칤l치, modr치, zlat치
        
        // Vytvo콏en칤 s칤t캩 bod콢 pro p칤smeno "F"
        function generateLetterPoints() {
          const points = [];
          const letterHeight = 3.0; // V캩t코칤 v칳코ka pro v칳razn캩j코칤 p칤smeno
          const letterWidth = 2.0; // 말r코칤 p칤smeno pro lep코칤 캜itelnost
          const thickness = 0.4; // Tlou코콘ka 캜ar p칤smena
          
          // Vertik치ln칤 캜치ra
          for(let y = -letterHeight/2; y <= letterHeight/2; y += 0.05) {
            for(let x = -thickness/2; x <= thickness/2; x += 0.05) {
              points.push([x, y, 0]);
            }
          }
          
          // Horn칤 horizont치ln칤 캜치ra
          for(let x = -thickness/2; x <= letterWidth; x += 0.05) {
            for(let y = letterHeight/2 - thickness/2; y <= letterHeight/2 + thickness/2; y += 0.05) {
              points.push([x, y, 0]);
            }
          }
          
          // St콏edn칤 horizont치ln칤 캜치ra (krat코칤)
          for(let x = -thickness/2; x <= letterWidth * 0.7; x += 0.05) {
            for(let y = 0 - thickness/2; y <= 0 + thickness/2; y += 0.05) {
              points.push([x, y, 0]);
            }
          }
          return points;
          return points;
        }

        const letterPoints = generateLetterPoints();
          const geometry = new THREE.SphereGeometry(0.03, 32, 32); // Je코t캩 v캩t코칤 a detailn캩j코칤 kuli캜ky
        
        for (let i = 0; i < particleCount; i++) {
          const material = new THREE.MeshPhongMaterial({
            color: colors[Math.floor(Math.random() * colors.length)],
            shininess: 250,
            opacity: 1,
            transparent: false,
            emissive: colors[Math.floor(Math.random() * colors.length)],
            emissiveIntensity: 0.3
          });          const particle = new THREE.Mesh(geometry, material);
          
          // N치hodn치 po캜치te캜n칤 pozice v u쮄뫆셠 prostoru pro rychlej코칤 formov치n칤
          particle.position.set(
            Math.random() * 20 - 10,
            Math.random() * 20 - 10,
            Math.random() * 10 - 5
          );
          
          // Ka쬯치 캜치stice dostane c칤lovou pozici z p칤smen
          const targetPoint = letterPoints[i % letterPoints.length];
          particle.targetPosition = new THREE.Vector3(...targetPoint);
          
          // Ulo쬰n칤 p콢vodn칤 pozice pro n치vrat
          particle.originalPosition = particle.position.clone();
          
          // P콏id치n칤 n치hodn칠 rychlosti pro rozlet
          particle.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.05,
            (Math.random() - 0.5) * 0.05,
            (Math.random() - 0.5) * 0.05
          );
          
          particles.push(particle);
          scene.add(particle);
        }

        camera.position.z = 10;

        let isMouseMoving = false;
        let mouseTimer;
        let transitionProgress = 0;

        // Animace
        function animate() {
          requestAnimationFrame(animate);
          
          // Aktualizace p콏echodu
          if (isMouseMoving && transitionProgress < 1) {
            transitionProgress = Math.min(1, transitionProgress + 0.02);
          } else if (!isMouseMoving && transitionProgress > 0) {
            transitionProgress = Math.max(0, transitionProgress - 0.01);
          }

          // Aktualizace 캜치stic
          particles.forEach((particle) => {
            if (isMouseMoving) {
              // Kdy se h칳be my코, v코echny 캜치stice sm캩콏uj칤 k p칤smen콢m
              particle.position.lerp(particle.targetPosition, transitionProgress * 0.1);
              // M칤rn치 rotace b캩hem formov치n칤 p칤smen
              particle.rotation.x += 0.005;
              particle.rotation.y += 0.005;
            } else {
              // Kdy se my코 neh칳be, 캜치stice se rozlet칤
              if (transitionProgress < 0.3) {
                // Aplikuj ulo쬰nou rychlost
                particle.position.add(particle.velocity);
                
                // P콏idej n치hodn칳 pohyb
                particle.velocity.x += (Math.random() - 0.5) * 0.01;
                particle.velocity.y += (Math.random() - 0.5) * 0.01;
                particle.velocity.z += (Math.random() - 0.5) * 0.01;
                
                // Omez rychlost
                particle.velocity.multiplyScalar(0.99);
                
                // Rotace 캜치stic p콏i rozletu
                particle.rotation.x += particle.velocity.length() * 0.2;
                particle.rotation.y += particle.velocity.length() * 0.2;
                
                // Omezen칤 prostoru
                if (Math.abs(particle.position.x) > 15) {
                  particle.velocity.x *= -0.8;
                  particle.position.x *= 0.95;
                }
                if (Math.abs(particle.position.y) > 15) {
                  particle.velocity.y *= -0.8;
                  particle.position.y *= 0.95;
                }
                if (Math.abs(particle.position.z) > 10) {
                  particle.velocity.z *= -0.8;
                  particle.position.z *= 0.95;
                }
              }
            }
          });
          
          renderer.render(scene, camera);
        }
        
        animate();

        // Responzivita
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Interaktivita s my코칤
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (event) => {
          mouseX = (event.clientX / window.innerWidth) * 2 - 1;
          mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
          
          // Nastaven칤 p콏칤znaku pohybu my코i
          isMouseMoving = true;
          clearTimeout(mouseTimer);
          
          // Timer pro detekci ukon캜en칤 pohybu
          mouseTimer = setTimeout(() => {
            isMouseMoving = false;
          }, 100);

          camera.position.x += (mouseX * 2 - camera.position.x) * 0.05;
          camera.position.y += (mouseY * 2 - camera.position.y) * 0.05;
          camera.lookAt(scene.position);
        });
      })();
      
      </script>
  </body>
  </html>
